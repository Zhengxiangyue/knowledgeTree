8个问题：

1.生成所有 n bit 的二进制串

2.生成{1，2，3，…，n}这个集合的所有子集

3.生成 n 个 nodes 可以构成的全部有向图

4.生成 n 个 nodes 可以构成的全部无向图

5.生成{1，2，3…，n}的permutation

6.给定一个图 G（V,E），生成它的所有 Hamiltonian cycles

7.给定一个图 G(V,E)，生成它的全部的 k-cliques

8.Generation of all k-colorings of a given graph G=(V,E) of n nodes, where k is an integer, 1 <= k <= n



结果 X[1:N]，刚开始全部初始化为a0,这个 a0不在 domain 中

当前的 index 位置 r，初始化为1

backtracking 的思想就是始终只维护一个数组和一个 index r，每一次获取下一个满足条件的当前 index 的值，这个值来自 domain，不同的问题 domain 可能不同。

获取下一个满足条件的值的方法是，首先简单的将 r 位置上的值变为 domain 里的下一个值，然后检查这前 r 个值是否满足条件，如果满足条件的话，r 移动到下一个位置（如果已经是最后一个位置就输出结果）。如果没有任何一个值可以满足条件，我们就把 r 移动到上一个位置。然后获取这个位置的next



以题6为例，首先先要找到一个用数组表示一个哈密顿回路的方法，这个数组长度是节点数，domain 是所有节点的 label，假设从1到 n，全部初始化成0（初始化成 domain 中最小的值-1），r 初始化成1。然后开始 getnext，此时数组在第一个位置上是0，getnext 就变成1，此时要检查数组前 r 个是否满足条件。

像哈密顿路径检查是否满足条件的方法就是检查当前位置是否和前面有重复，有重复的话肯定不行，然后要看当前的点和上一个位置的点是否有边相连，如果没有的话也不行，满足了这两个条件，就算getnext 成功了，如果不满足就 label 继续+1，直到加到超过了 domain，说明这个位置没有满足条件的值了，r 需要往前移动一个。

当 r回到了第一个位置的前面，说明遍历完了所有可能的结果。



所以 backtracking 的重要的初始量有三个，表示结果的数组，domain，和 a0，一般 a0是比 domain 中最小元素小1的值