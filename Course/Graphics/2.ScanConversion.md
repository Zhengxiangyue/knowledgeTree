通过透视变换，有了一个压缩的空间，但是如果把所有的点按照面提供的点之间的连线关系连起来，所有的面都会显示出来，没有遮挡关系

所以要用一种方法来确定，一个像素点应该显示哪个平面上的点（显示成什么样子是后面考虑的问题，由法向量和光照决定）

这个过程由“边表”和“活边表”来确定，边表记录了所有边的信息，活边表记录了与当前扫描线相交的边信息

这个设计说巧妙也巧妙，说笨拙也笨拙

边表里面的元素自然是边，边表可以用一个数组或 vector 容器实现

其中 index 用来表示一条边的 y 坐标的较小值，也就是如果有一条边的较低的顶点在 y = 3 这个位置，这个边就存在 edgeTable[3]这个位置

edgeTable[0]不存储任何东西

容器内每个位置都存储了一个地址，指向一条“边”，描述这个边的信息包括另外三个元素

> 1.Ymax，较高的顶点的y坐标
>
> 2.Xmin，较低的顶点的 x 坐标，还记得 index 就是这个点的 y 坐标吗？
>
> 3.$\Delta X\ over\ \Delta Y $ ，这个自然就是斜率

讲义中的意思是用链表来实现，容器每个 index的位置都延伸出一个链表，但我不确定这样是否高效，所以在第一次实现项目的时候选择了二维 vector 来实现

![creen Shot 2018-03-20 at 5.08.03 P](/Users/Cancel/Course/gitbooks/knowledgeTree/assets/Graphics/Screen Shot 2018-03-20 at 5.08.03 PM.png)

通过线性时间来建立 edge table，这个线性时间指的是面的个数而不是边的个数，通常情况下一条边被两个面公用，那么这个边会两次被记录在边表里面

在生成边表的时候，以 polygon 为单位，每次加入一个 polygon 的所有边

这里的三个细节是

1.每个 polygon 的边的数目是确定的，组成这个 polygon 的最后一条边是最后一个点和第一个点

2.在录入边的时候就确定哪个是高点，哪个是低点

3.如果这条边是水平的，可以忽略这条边，因为它不对渲染产生任何影响

到这里有一个细节问题产生了，现在点的信息全部都属于那个归一化的空间里了，要把这些点再放到真实屏幕中的位置中去了，不过这个过程倒不难，都是细节问题

为了实现这个过程，写两个辅助函数，它们把一个归一化空间中的点变换到屏幕空间，当然只关心 x 和 y 坐标就可以了

为什么是两个辅助函数？因为一个转换成 int 类型，一个转换成 double 类型，在“边表元素”数据结构中，其实我很想把所有东西都用 double 来表示，但是后面会发现两个点的 y 坐标有非常重要的作用，那就是作为边表容器的索引

所以在一开始就使用确定的整型来存储 y 坐标，省去了一些后面转换的麻烦，但是还是用 double 类型存储了有关 x 的信息

其实边表元素的结构中，除了之前提到的三个信息，我还存储了Ymin以及两个 z 坐标

回到辅助函数，如果我们考虑足够深远，就能够发现一些问题（但是用了我自己的顺序，而非老师上课提供的顺序，似乎没这个问题了！）

之后的活边表的工作流程是这样的：

刚开始活边表是空的，从 y = 1 开始

每当 scan line 爬升到一个新的 y 值，首先要整理自己当前与哪些边在哪些位置有交点，整理的过程包括：

> **1.如果当前这个位置有新的边相交，也就是 edge_table[y]里面有东西，那么就把这里面的所有东西加入边表**
>
> **2.如果当前这个位置有一个边即将结束和 scan line 相交，也就是这条边结构里面的 Ymax 等于 y 了，那么就去除这条边**
>
> **3.要对活边表里面的边结构按照当前相交点的 x 值从小到达来排序**

也就是说，整理完成的活边表可以准确表述 scan line上的交点，scan line 只关心当前这一个 y 坐标的所有像素值应该如何染色

![creen Shot 2018-03-20 at 5.49.18 P](/Users/Cancel/Course/gitbooks/knowledgeTree/assets/Graphics/Screen Shot 2018-03-20 at 5.49.18 PM.png)

通过这些交点的奇偶，我们还可以知道哪些部分在 polyton 内部，哪些部分在 polygon 外部

**对了，之所以这样，是因为 scan conversion 是一个 polygon 一个 polygon 进行的，换句话说每个 polygon 都记录自己的边表，每个 polygon 都从底到上扫描一遍**

先来说下之前说的出现的问题，就是在一个扫描线在同一个交点可能有两个元素都存储在活边表里面，导致算法无法正确的判断奇偶，内外

但是在整理的过程中发现这个问题是由于老师提供的算法的顺序造成的：

1.先把边表里面的东西加入活边表，这一步一样

2.Fill in desired pixel values on scan line y by using pairs of x-coordinates from the AET

3.Remove from AET entried for which y = ymax

(之后更新交点坐标的步骤省略)

问题就出在，这个步骤先填充了颜色，后面才把即将结束的点移除

在我看来这个步骤是有问题的，因为在填充的时刻交点信息还是不正确的，所以要通过上文所述“考虑足够深远”的方法才能解决，那就是把一个边的交点做 shorten 处理

实验之后是可以的，代码简化了很多，这样避免了使用 shorten 机制，避免了两次排序，但仍然不知道有没有潜在的问题

下章来总结光照模型



