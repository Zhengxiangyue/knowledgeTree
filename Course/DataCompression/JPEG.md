1.“水平移位”,移位量为2^(p-1),也就是说从每个像素减去2^(p-1),其中 p 是表示每个像素的比特数，因此如果我们处理8比特/像素的（像素值介于0~255之间）的图像，则可以从每个像素中减去128，使像素值在-128到127之间变换

2.对8x8的块进行 DCT 变换，如果列或行不是8的倍数，就复制最后一列或最后一行知道最终大小为8的倍数为止（这些增加的行货列将在编码过程中被删除）

3.量化，对每个变换后的8x8矩阵进行量化。给定一个量化表，它也是一个8x8的矩阵，量化的方式是位对位点除，也就是矩阵点除后四舍五入至整数。（参考书中是位对位点除后+0.5再四舍五入）

（将标记值乘以量化表中的相应项目，即可得到重构值）

（对于量化后的数据，左上角对应高频信号，右下角对应低频信号->大多是0，所以对一个矩阵中的数据进行编码时，在一个非零数据后面跟一个 EOB 代码，就可以对扫描尾部的整个零串进行编码，实现重大压缩）

（此外，这一效果还提供了一种改变速率的方法，使步长增大，就可以减少需要穿送的非零值数目，这就相当于减少了需要传送的比特数）

4.对于 DC 系数，有意义的做法是对相邻的差值进行编码，而不是对标记本身编码

**假设 DC term 的范围是[-2047,2047]**(暂时不太理解为什么是这个范围，但是不影响后续计算)

所以DC terms 的 magnitude 的范围是 0 到 2047 = 2^11 - 1

用以下方式分块并进行哈夫曼编码：

把这个范围分成12个更小的范围，叫做 category0 到 category11，其中 category0只包含一个元素0，categoryk 包含2^(k-1)到2^k - 1

对于一个 DCterms 中的元素 r，可以表示成 |r| = 2^(k-1) + t ,  **0 <= t <= 2^(k-1)-1**的形式

并且t 可以用 k-1位来表示，再用1位s来表示它的符号，那么r 就可以用 s，k，t 来表示

**说白了 k 就是对 r 求以2为底的对数的整数部分+1，然后再确定 r 是这个 range 中的第几个就可以了，第 k 个 range 中有2^k 个数,可以用k位表示，和上面说的先求绝对值，用 k-1位表示，再用1位表示符号是一样的.其实也有些许不一样，因为绝对值的顺序变了，所以那 k-1位还是有些不一样的，两者应该都可以，书上和 handout 上不同，以 handout 为准**

下面的表格显示了 range(k)（从0到11）分别对应了哪些 r(DPCM 后的差值)

0	0

1	-1 1

2	-3 -2 2 3

3	-7 -6 -5 -4 4 5 6 7

...

11	-1023 -1022… -512 512 … 1022 1023

比如 r 是6，那么 2 < log6 < 3 于是 k 就是3了，6是 range为3中的 index 为6的数（index 从0开始比较方便），3位来表示index位6的数就是110。

我们需要找出拥有12个元素的哈夫曼树，就是 k 从0到11的12个元素，因为每一个 DPCM 后的值（r）都可以对应一个 k，所以可以求出来 这12个元素的概率，然后建立哈夫曼树

于是每一个 DC residual（DPCM 后的值 ）r 都可以用二进制表示为 **hsm**,其中 h 是哈夫曼树的 codeword，s 是上面提到的 r 的符号位，0表示小于0，1表示大于0，m 是用 k-1位表示的 t



5.对 AC terms 进行编码

所有 AC terms 的绝对值都小于等于 2^10 - 1（依旧不知道为什么）

对于一个非0的 ACterms，称之为 x，我们还需要知道d，d代表x前面有多少个0（这个前面指的是 zigzag 重拍以后的序列），也就是它和上一个非零 AC term 之间有多少个零，一组可以表示为(d,x)

把 AC terms 的范围分成10个范围，用相同的方式来表示x，注意计算 k 的方式是一样的，都可以参考上面的表格，只不过范围小了一些，只用到前10行。我们还用相同的表示方式，x 可以表示为第 k 个 range 里的第 (s,t）个数，s 是符号位，s 和 t 一共占 k 位。

于是（d，x）可以表示为（d，k，s，t）,并且注意到 d 的范围是0到62，因为在一个8*8的 block 中，最远中间只能相隔62个0，也就是只有最后一个元素是非零元素的情况（几乎不可能存在吧）

接下来我们用这种方式表示 d：

d = 15p + r, r = 0,1,2…14

r 可以用4位来表示 r3r2r1r0

p can be represented with
$$
11110000_{1} 11110000_{2} ... 1111000_{p}
$$
所以 d 可以表示成
$$
11110000_{1} 11110000_{2} ... 1111000_{p}r_{3}r_{2}r_{1}r_{0}
$$
然后 k 有从0到9（讲义上写的从1到10），可以用4位来表示
$$
k_{3} k_{2} k_{1} k_{0}
$$
所以(d,k)最终可以表示为
$$
11110000_{1} 11110000_{2} ... 1111000_{p}r_{3}r_{2}r_{1}r_{0}k_{3} k_{2} k_{1} k_{0}
$$
这一共可以用 p+1字节表示



这样表示下来，为了构建哈夫曼树，r3r2r1r0表示的是从0到14，有15种表示，k3k2k1k0表示的是从0到9，有10种表示，所以最有一个字节有15*10=150种表示方法，再加上11110000以及 EOB 两个符号，一共有152种符号用来构建哈夫曼树



JPEG encodes each quantized AC term (d,x)=(d,k,s,t) as 

**hsm** where

-  h is the Huffman codeword of (d,k)
-  s= sign of the term; s=0 if negative, 1 if positive
-  m= the (k-1)-bit binary representation of t.

 所以是对 d，k 进行了哈夫曼编码，要注意本来 k 和 sm 是一起的，但是没有对 sm 进行哈夫曼编码