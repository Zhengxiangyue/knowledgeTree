关键是理解和找出**短字符串**中每一个**以第一个字符开始的子字符串**的**最长公共前后缀**

这个过程只和**短字符串**有关，复杂度是 O(n)

例如短字符串 ababc，“以第一个字符串开始的子字符串”包括以下几个：

```
a
ab
aba
abab
ababc
```

最长公共前后缀就是表面意思。。前缀，后缀，一样的最长长度。当然这个长度要小于字符串的长度，也就是说字符串本身不算做字符串的一个前缀或者后缀

a 没有公共最长前后缀，单个字母都没有公共最长前后缀，它的长度是零

ab，长度也是0

aba，长度是1，因为可以有一个前缀是 a，后缀也是 a 的两个公共前后缀

abab，长度是2，因为可以有一个前缀是 ab，后缀也是 ab 的公共前后缀

ababc，长度是0，

在KMP 中不用求短字符串本身的公共前后缀

求出来以后把公共前后缀长度和 index 同时写在短字符串的下面和上面，但是公共前后缀长度要放后退一位, 并且第一位以-1来填充

```
0   1  2  3  4  5
a   b  a  b  c
-1  0  0  1  2  0
       a  b  a  b  c
```

这个公共前后缀长度代表的意思是：当本位匹配到不一样的字符的时候，把整个短字符串往后移动使得此 index 和此位置对应。这 tm 是啥意思呢？就是如果前面都匹配的好好的，到最后一个 c 的时候匹配失败了，把 index 为2的字符移动到这个位置，使得整个字符串往后移动两位，且下一次从此位置开始比较就可以了

来分析一下为什么有效，为什么 c 匹配不上了就把index 为2的位置移动过来就行了。c 下面的这个2是刚才求的 abab 的公共前后缀，它代表的意思是**这个字符串的前两位可以和 c 的前面两位匹配上**，因为这个**字符串的前两位**和 **c 前面的前两位**就是刚才求的 abab 的最长公共前后缀！！

所以好像这个表可以简化一下，每个位置匹配不上都唯一对应了下一次应该往后面移动几个位置，就是上面那张表两个数相减，得到

```
1  1  2  2  2  5
a  b  a  b  c
```

不管这个字符串匹配什么长的字符串，哪一位没匹配上，就把它往后移动相应的数字就可以了，这个数字保证的是移动过之后此位置之前都是匹配好的。如果全都匹配上了，那再