字符串匹配自动机

![statusMachine](/Users/Cancel/Course/gitbooks/knowledgeTree/assets/statusMachine.jpeg)

假如我们要在一个较长的文本中查找 ababaca。

如图是 ababaca 的状态机，我们首先关心的是这个字符串包含哪些字符，它包含 a，b，c 三个字符。

状态机的工作模式：状态机有 n+1 个状态，n 是字符串的长度，从 0 到 n。这 n 个状态是谁的状态？是要搜索文本的每个位置的状态。

对于**较长文本的每个位置**，都对应状态机中的一个状态，这个状态 i 的代表的是：此位置（文本中的某位置）之前的 i 个字符都可以匹配 ababaca 的前 i 个字符，保证 i 是最大的，i 就是这个位置的状态

e.g. 文本 **haifabafjlakdfiafkladjfab**baafaid，加粗的部分最后一个字符为 b，这个位置之前的字符最多可以匹配 ababaca 中的前两个字符 ab，所以这个位置的状态是2，如果在某一个位置，状态到达7了，显然就找到了这个字符串在文本中的位置。如果我们再往下看一个字符b，可以根据图中的状态机发现，在状态2时没有对应下一个是 b 的状态，这意味着我们要回到状态0了，因为这个b 使得前面没有任何长度的字符可以匹配了。

稍后我们再看状态机是如何产生的，先 ab*ababaca*babacab 试着用状态机来在这个文本里搜索一下 ababaca：

从状态0开始，只有碰到 a 才变为状态1，第一个字符就是 a，所以第一个位置的状态是1

第二个位置的状态是2，第三个位置的状态是3，第四个位置是状态4， 第五个位置的状态是5，到目前似乎一切都很顺利，前5个字符刚好全部匹配，我们期待下个字符是 c，这样就可以到达状态6了，但是下一个字符是 b，根据状态机，我们回到了状态4，还好，状态机帮我们维持了比较好的状态，它发现即使下一个字符匹配不了了，我们仍然可以用当前位置结尾的4个字符去匹配 ababaca 中的前4个字符。接下来一帆风顺了，依次来到了状态5，6，7，当发现有位置的状态是7了，我们就找到了字符串。

可以看到利用自动机匹配时和暴力解法的些许不同：当第6个字符不是期待中的 c 的时候，暴力解法将放弃之前所做的部分工作，因为它相信自己此前所做的工作都是基于搜索文本的第一个字符完成的，扫到的第六个字符不是期待中的 c，说明不能从第一个字符开始匹配，于是暴力解法又回到第二个字符从心开始匹配。

而利用自动机，我们似乎多了很多信息。

如何建立自动机？

