STL allocator 理解和总结

#### 第一级空间适配器

好理解的是 allocate 函数，调用 malloc 函数向操作系统要内存，然后返回内存地址

如果操作系统分配失败，调用了oom_malloc

#### oom_malloc

这函数感觉看着异常屌，内存都分配失败了，还有啥办法？omit 啥东西然后可以继续 malloc？？

这个函数刚开始定义了函数指针 my_malloc_handler，这个东西在后面会被赋值为“**内存分配失败处理例程**”。然后接下来的事情就非常有意思了，不断循环，循环里面做的事情就是

1.首先给 my_malloc_handler赋值，让它变成coder之前定义好的__malloc_alloc_oom_handler-内存分配失败处理例程，如果coder没有定义这个东西，抛出 bad_alloc的异常，怎么处理这个异常似乎也由 code 决定，可以继续抛出这个异常，也可以直接退出程序。

如果 coder 定义了这个处理例程，紧接着就执行它（它企图释放内存），执行完了之后调用 malloc，能不能成功好像全凭刚才的处理例程做了哪些工作，或者企盼在这期间有其他进程释放了内存空间？如果成功了就返回，如果不成功就一直循环下去。

这个处理例程好像被坚信可以完成一些工作，只要它被定义了，就直到内存分配成功才返回。

还有一个值得注意的是每次循环都会重新给 my_malloc_handler 重新赋值，似乎这个处理例程也是可以动态变化的（58）

#### set_malloc_handler

这个函数可以设定自己的处理例程，这个处理例程初始值被设置为0，所以 coder 必须对它进行设定？？这个函数的功能就是 set_new_handler一样

#### oom_realloc

道理一样，多了一个地址参数，因为要再这个地址上 realloc

看来一级空间适配器除了“处理例程”没有做什么事，这个处理例程还得是 coder 自己来定义的（Meyers98条款7讨论“内存不足处理例程”的设计模式）

#### 第二级空间配置器

二级空间适配器里面有两个东西，free_list 和内存池

free_list 是一个大小为16(这个数字可以变的)的数组，存的是这玩意儿的指针

```
union obj {
    char content[1];
    union obj* nextObj;
};
```

所以 free_list 的定义是这个样子的:

```
obj *free_list[16];
```

